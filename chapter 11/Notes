
## **chapter 11  character strings and string functions**

This chapter discusses the nature of strings, how to declare and initialize strings, 
how to get them into and out of programs, and how to manipulate strings.

### Representing Strings and String I/O
1. A character string is a char array terminated with a null character (\0)

2. The puts() function, like printf() , belongs to the the stdio.h family of input/output functions.
It only displays strings, and, unlike printf() , it automatically appends a newline to the
string it displays.

#### Defining strings with a program

The principal ways to define a string are using string constants, usning char arrays and using char pointers.

##### character string literals (string constants)

A string literal, also termed a string constant, is anything enclosed in double quotation marks.
The enclosed characters, plus a terminating \0 character automatically provided by the compiler,
are stored in memory as a character string. 

   Eg:
      " I am a symbolic string constant"     (display)
      " I am a symbolic string constant\0"   (store in memory)

1. C concatenates string literals if they are seperated by nothing or by whitespace.

    Eg: 
       char greeting[50] = "Hello, and"" how are"    " you"" today!";
       is equivalent to this:
       char greeting[50] = "Hello, and how are you today!";
       
2. If you want to use a double quotation mark within a string, precede the quotation mark with a
   backslash, as follows:
   
     printf("\"Run, Spot, run!\" exclaimed Dick.\n");
     This produces the following output:
     "Run, Spot, run!" exclaimed Dick.
 3. character string constants are placed in static storage class, which means that if you use a string
    constant in a function, the string is stored just once and lasts for the duration of the program,
    even if the function is called several times. The entire quoted phrase ascts as a pointer to where 
    the string is stored, similar to the name of an array.
    Eg:
     #include <stdio.h>
      int main(void)
      {
        printf("%s, %p, %c\n", "We", "are", *"space farers");
        return 0;
       }
       The output is:
       We, 0x00000f61, s
 
 ##### Character string arrays and initilization
 
1.  When you define a character string array, you must let the compiler know how much space is needed.
 Eg: 
  const char m1[40] = "Limit yourself to one line's worth.";
  
  This form of initialization is short for the standard array initialization form:
  const char m1[40] = { 'L','i', 'm', 'i', 't', ' ', 'y', 'o', 'u', 'r', 's', 'e', 'l',
     'f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ',
    'l', 'i', 'n', 'e', '\", 's', ' ', 'w', 'o', 'r',
    't', 'h', '.', '\0'
     };
     Note the closing null character. without it, you have a character array, but not a string.
   Eg:
    const char m2[] = "If you can't think of anything, fake it.";
    Letting the compiler compute the size of the array works only if you initialize the array.
 
 2. Indeed, you can use pointer notation to set up  a string.
    
    const char *pt1 = "something is pointing at me.";
    const char ar1[] = "something is pointing at me"
    Both pt1 and ar1 are address of strings.
    
 
 ##### Array versus pointer
  
1. Difference between an array and a pointer form
    The array form ( ar1[] ) causes an array of 29 elements (one for each character plus one for the terminating '\0' )
    to be allocated in the computer memory. Each element is initialized to the corresponding character of the string literal. 

2. Typically, The quoted string is stored in a data segment that is part of the executable file; 
  when the program is loaded into memory, so is that string. The quoted string is said to be in static memory . 
   But the memory for the array is allocated only after the program begins running. 
   At that time, the quoted string is copied into the array.  
   Note that, at this time, there are two copies of the string. One is the
  string literal in static memory, and one is the string stored in the ar1 array.
3. Hereafter, ar1 = &ar1[0] .  ar1 is an address constant .
   ar1+1 is valid, but ++ar1 is not allowed.  
4. The pointer form ( *pt1 ) also causes 29 elements in static storage to be set aside for the string.
    In addition, once the program begins execution, it sets aside one more storage location for the
    pointer variable pt1 and stores the address of the string in the pointer variable. 
  
  Eg:
  // addresses.c -- addresses of strings
#define MSG "I'm special."
#include <stdio.h>
int main()
{
char ar[] = MSG;
const char *pt = MSG;
printf("address of \"I'm special\": %p \n", "I'm special");
printf(" address ar: %p\n", ar);
printf(" address pt: %p\n", pt);
printf(" address of MSG: %p\n", MSG);
printf("address of \"I'm special\": %p \n", "I'm special");
return 0;
}

Here's the output from one system:

address of "I'm special": 0x100000f0c
address ar: 0x7fff5fbff8c7
address pt: 0x100000ee0
address of MSG: 0x100000ee0
address of "I'm special": 0x100000f0c

What does this show?
1. pt and MSG are the same address, while ar is a different address, just as promised. 
2. although the string literal "I'm special." occurs twice in theprintf() statements,
  the compiler chose to use one storage location, but not the same address as MSG . 
  The compiler has the freedom to store a literal that’s used more than once in one or
   more locations. Another compiler might choose to represent all three occurrences of "I'm
   special." with a single storage location. 
3. the part of memory used for static data is different from that used for dynamic memory, 
      the memory used for ar. 
      

##### Array and pointer differences


     char heart[] = "I love Tillie!";
     const char *head = "I love Millie!";
     
1.  The chief difference is that the array name heart is a constant, but the pointer head is a variable.
 Eg: head = heart; is valid, but heart = hear; is illegal construction
 
2. Let’s go back to a pointer initialization that doesn’t use the const modifier:

   char * p1 = "Klingon";
   Can you use the pointer to change this string?
   p1[1] = 'F'; // allowed??
   
   Eg, the following statements could all refer to a single memory location of string "Klingon". 
   char * p1 = "Klingon";
   p1[0] = 'F'; // ok?
   printf("Klingon");
   printf(": Beware the %ss!\n", "Klingon");
   
 That is, the compiler can replace each instance of "Klingon" with the same address. If the
 compiler uses this single-copy representation and allows changing p1[0] to 'F' , that would
 affect all uses of the string, so statements printing the string literal "Klingon" would actually
 display "Flingon" :
 Flingon: Beware the Flingons!
 
 Therefore, the recommended practice for initializing a pointer to
 a string literal is to use the const modifier:
 const char * pl = "Klingon"; // recommended usage
 
Initializing a non- const array with a string literal, however, poses no such problems, because
the array gets a copy of the original string.
In short, don’t use a pointer to a string literal if you plan to alter the string.
 
##### Arrays of character strings

It is often convenient to have an array of character strings. Then you can use a subscript to
access several different strings.

Eg:
(1). an array of pointers to strings

     const char *mytalents[LIM] = {
           "Adding numbers swiftly",
            "Multiplying accurately", "Stashing data",
            "Following instructions to the letter",
            "Understanding the C language"
          };
          
  (2). an array of char arrays
  
     char yourtalents[LIM][SLEN] = {
           "Walking in a straight line",
           "Sleeping", "Watching television",
            "Mailing letters", "Reading email"
          };
  
     
  1. In some ways, mytalents and yourtalents are much alike. Each represents five strings. When
    used with one index, as in mytalents[0] and yourtalents[0] , the result is a single string.
    And, just as mytalents[1][2] is 'l' ,  yourtalents[1][2] is 'e'. Both are initialized in the same fashion.
    
  
   2. But there are differences, too. The mytalents array is an array of five pointers, taking up 40
     bytes on our system. But yourtalents is an array of five arrays, each of 40 char values, occupying
     200 bytes on our system. So mytalents is a different type from yourtalents , even
     though mytalents[0] and yourtalents[0] both are strings. The pointers in mytalents point
     to the locations of the string literals used for initialization, which are stored in static memory.
     The arrays in yourtalents , however, contain copies of the string literals, so each string is
     stored twice. Furthermore, the allocation of memory in the arrays is inefficient, for each
     element of yourtalents has to be the same size, and that size has to be at least large enough to hold the longest string.
     
   3. One way of visualizing this difference is to think of yourtalents as a rectangular two-dimensional
      array, with each row being of the same length, 40 bytes, in this case. Next, think of
      mytalents as a ragged array, one in which the row length varies.   
      
       
        char fruit1[3][7] = {"Apple", "Pear", "Orange"}; // retangular array
        A   p   p   l   e   \0   \0
        P   e   a   r  \0   \0   \0
        O   r   a   n   g    e   \0
        
       const char *fruit2[3] = {"Apple", "Pear", "Orange"};  // ragged array
        A   p   p   l   e   \0  
        P   e   a   r  \0   
        O   r   a   n   g    e   \0
      
     4. The upshot is that, if you want to use an array to represent a bunch of strings to be displayed,
        an array of pointers is more efficient than an array of character arrays. There is, however, a
        catch. Because the pointers in mytalents point to string literals, these strings shouldn’t be
        altered. The contents of yourtalents , however, can be changed. So if you want to alter strings
        or set aside space for string input, don’t use pointers to string literals.
        
 ##### Pointers and strings
 Most C operations for strings actually work with pointers.
 
 
 
        
        
        
        
        
 
       
    




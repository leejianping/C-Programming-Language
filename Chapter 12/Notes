
## Chapter 12 Storage classes, linkage, and memory management

One of C’s strengths is that it enables you to control a program’s fine points. C’s memory
management system exemplifies that control by letting you determine which functions know
which variables and for how long a variable persists in a program. Using memory storage is one
more element of program design.

### Storage classes
C provides several different models, or storage classes , for storing data in memory.

Every programming example in this book stores data in memory. There is a hardware aspect
to this—each stored value occupies physical memory. C literature uses the term object for such
a chunk of memory. An object can hold one or more values. An object might not yet actually
have a stored value, but it will be of the right size to hold an appropriate value. (The phrase
object-oriented programming uses the word object in a more developed sense to indicate class 
objects, whose definitions encompass both data and permissible operations on the data; C is
not an object-oriented programming language.)

There also is a software aspect—the program needs way to access the object. This can be
accomplished, for instance, by declaring a variable:

int entity = 3;

This declaration creates an identifier called entity . An identifier is a name, in this case one
that can be used to designate the contents of a particular object.In this case, the identifier
entity is how the software (the C program) designates the object that’s stored in hardware
memory. This declaration also provides a value to be stored in the object.

A variable name isn’t the only way to designate an object. For instance, consider the following
declarations:
int * pt = &entity;
int ranks[10];

In the first case, pt is an identifier. It designates an object that holds an address. 
Next, the expression *pt is not an identifier because it’s not a name. However, it does designate an object, 
in this case the same object that entity designates. In general, as you may recall from
Chapter 3 , “Data and C,” an expression that designates an object is called an lvalue.
So entity is an identifier that is an lvalue, and *pt is an expression that is an lvalue.
Along the samelines, the expression (ranks + 2 * entity) is neither an identifier (not a name) nor an lvalue
(doesn’t designate the contents of a memory location). But the expression *(ranks + 2 *entity) 
is an lvalue because it does designate the value of a particular memory location, the
seventh element of the ranks array (rank[6]). The declaration of ranks , by the way, creates an object
capable of holding ten ints , and each member of the array also is an object.

If, as with all these examples, you can use the lvalue to change the value in an object, it’s a
modifiable lvalue . Now consider this declaration:

const char * pc = "Behold a string literal!";

This causes the program to store the string literal contents in memory, and that array of character
values is an object. Each character in the array also is an object, as it can be accessed
individually. The declaration also creates an object having the identifier pc and holding the
address of that string. The identifier pc is a modifiable lvalue because it can be reset to point to
a different string. The const prevents you from altering the contents of a pointed-to string but
not from changing which string is pointed to. So *pc , which designates the data object holding
the 'B' character, is an lvalue, but not a modifiable lvalue. Similarly, the string literal itself,
because it designates the object holding the character string, is an lvalue, but not a modifiable
one.
You can describe an object in terms of its storage duration , which is how long it stays in
memory. You can describe an identifier used to access the object by its scope and its linkage ,
which together indicate which parts of a program can use it. The different storage classes offer
different combinations of scope, linkage, and storage duration. You can have identifiers that
can be shared over several files of source code, identifiers that can be used by any function in
one particular file, identifiers that can be used only within a particular function, and even identifiers
that can be used only within a subsection of a function. You can have objects that exist
for the duration of a program and objects that exist only while the function containing them is
executing. With concurrent programming, you can have objects that exist for the duration of
a particular thread. You also can store data in memory that is allocated and freed explicitly by
means of function calls.

Next, let’s investigate the meaning of the terms scope , linkage , and storage duration . After that,
we’ll return to specific storage classes.

#### Scope

Scope describes the region or regions of a program that can access an identifier. A C variable
has one of the following scopes: block scope, function scope, function prototype scope, or file
scope . The program examples to date have used block scope almost exclusively for variables. A
block , as you’ll recall, is a region of code contained within an opening brace and the matching
closing brace. For instance, the entire body of a function is a block. Any compound statement
within a function also is a block. A variable defined inside a block has block scope , and it is
visible from the point it is defined until the end of the block containing the definition. Also,
formal function parameters, even though they occur before the opening brace of a function,
have block scope and belong to the block containing the function body. So the local variables
we’ve used to date, including formal function parameters, have block scope. Therefore, the variables
cleo and patrick in the following code both have block scope extending to the closing
brace:

double blocky(double cleo)  // cleo 
{
  double patrick = 0.0;
   ...
   return patrick;
}

Variables declared in an inner block have scope restricted just to that block:

double blocky(double cleo)
{
  double patrick = 0.0;
  int i;
  for (i = 0; i < 10; i++)
   {
      double q = cleo * i; // start of scope for q
      ...
      patrick *= q;
   }                       // end of scope for q
   ...

   return patrick;
 }
 
 
 C99 allowing you to declare variables anywhere in a block, Eg:
 
 for (int i = 0; i < 10; i++)
     printf("A C99 feature: i = %d", i);
     
     
As part of this new feature, C99 expanded the concept of a block to include the code controlled
by a for loop, while loop, do while loop, or if statement, even if no brackets are used. So in
the previous for loop, the variable i is considered to be part of the for loop block. Therefore,
its scope is limited to the for loop. After execution leaves the for loop, the program will no
longer see that i .

Function scope applies just to labels used with goto statements. This means that even if a label
first appears inside an inner block in a function, its scope extends to the whole function. It
would be confusing if you could use the same label inside two separate blocks, and function
scope for labels prevents this from happening.
Function prototype scope applies to variable names used in function prototypes, as in the following:

int mighty(int mouse, double large);

Function prototype scope runs from the point the variable is defined to the end of the prototype
declaration. What this means is that all the compiler cares about when handling a function
prototype argument is the types; the names you use, if any, normally don’t matter, and
they needn’t match the names you use in the function definition. One case in which the
names matter a little is with variable-length array parameters:

void use_a_VLA(int n, int m, ar[n][m]);

If you use names in the brackets, they have to be names declared earlier in the prototype.
A variable with its definition placed outside of any function has file scope . A variable with file
scope is visible from the point it is defined to the end of the file containing the definition. Take
a look at this example:

#include <stdio.h>
int units = 0; /* a variable with file scope */
void critic(void);
int main(void)
{
...
}

void critic(void)
{
...
}

Here, the variable units has file scope, and it can be used in both main() and critic() .
(More exactly, units has file scope with external linkage, a distinction we’ll cover in the next
section.) Because they can be used in more than one function, file scope variables are also
called global variables .


#### Linkage

Next, let’s look at linkage. A C variable has one of the following linkages: external linkage,
internal linkage, or no linkage . Variables with block scope, function scope, or function prototype
scope have no linkage. That means they are private to the block, function, or prototype in
which they are defined. A variable with file scope can have either internal or external linkage.
A variable with external linkage can be used anywhere in a multifile program. A variable with
internal linkage can be used anywhere in a single translation unit.

Some common short cuts are to use “file scope” for “file scope with internal linkage” and “global scope” or “program scope”
for “file scope with external linkage.”

Eg:

int giants = 5; // file scope, external linkage
static int dodgers = 3; // file scope, internal linkage
int main()
{
...
}
...

The variable giants can be used by other files that are part of the same program. The dodgers
variable is private to this particular file, but can be used by any function in the file.


#### Storage duration

Scope and linkage describe the visibility of identifiers. Storage duration describes the persistence
of the objects accessed by these identifiers. A C object has one of the following four storage
durations: static storage duration, thread storage duration, automatic storage duration, or allocated
storage duration .

If an object has static storage duration, it exists throughout program execution. Variables with
file scope have static storage duration. Note that for file scope variables, the keyword static
indicates the linkage type, not the storage duration. A file scope variable declared using static
has internal linkage, but all file scope variables, using internal linkage or external linkage, have
static storage duration.

Thread storage duration comes into play in concurrent programming, in which program execution
can be divided into multiple threads. An object with thread storage duration exists from
when it’s declared until the thread terminates. Such an object is created when a declaration
that would otherwise create a file scope object is modified with the keyword Thread_local .
When a variable is declared with this specifier, each thread gets its own private copy of that
variable.

Variables with block scope normally have automatic storage duration. These variables have
memory allocated for them when the program enters the block in which they are defined, and
the memory is freed when the block is exited. The idea is that memory used for automatic variables
is a workspace or scratch pad that can be reused. For example, after a function call terminates,
the memory it used for its variables can be used to hold variables for the next function
that is called.

Variable-length arrays provide a slight exception in that they exist from the point of declaration
to the end of the block rather than from the beginning of the block to the end.
The local variables we’ve used so far fall into the automatic category. For example, in the
following code, the variables number and index come into being each time the bore() function
is called and pass away each time the function completes:

void bore(int number)
{
int index;
for (index = 0; index < number; index++)
puts("They don't make them the way they used to.\n");
return 0;
}

It is possible, however, for a variable to have block scope but static storage duration. To create
such a variable, declare it inside a block and add the keyword static to the declaration:
void more(int number)

{
int index;
static int ct = 0;
...
return 0;
}

Here the variable ct is stored in static memory; it exists from the time the program is loaded
until the program terminates. But its scope is confined to the more() function block. Only
while this function executes can the program use ct to access the object it designates.
(However, one can allow indirect access by enabling the function to provide the address of the
storage to other functions, for example, by a pointer parameter or return value.)
C uses scope, linkage, and storage duration to define several storage schemes for variables. This
book doesn’t cover concurrent programming, so we won’t go into that aspect. And we’ll discuss
allocated storage later in this chapter. That leaves five storage classes: automatic, register, static
with block scope, static with external linkage, and static with internal linkage. Table 12.1 lists
the combinations. Now that we’ve covered scope, linkage, and storage duration, we can discuss
these storage classes in more detail.
________________________________________________________________________________________________________________________
Storage Class           Duration       Scope          Linkage              How Declared
________________________________________________________________________________________________________________________
automatic                Automatic     Block            None               In a block

register                 Automatic     Block            None               In a block with the keyword register

static with
external linkage         static        File            External            Outside of all functions

static with
internal linkage         Static        File             Internal           Outside of all functions with the keyword static


static with no
linkage                   Static        Block            None                In a block with thekeyword static
___________________________________________________________________________________________________________________________


#### Automatic variables

A variable belonging to the automatic storage class has automatic storage duration, block scope,
and no linkage. By default, any variable declared in a block or function header belongs to the
automatic storage class. You can, however, make your intentions perfectly clear by explicitly
using the keyword auto , as shown here:

  int main(void)
   {
      auto int plox;
      ....
    }
    
You might do this, for example, to document that you are intentionally overriding an external
variable definition or that it is important not to change the variable to another storage class.
The keyword auto is termed a storage-class specifier . C++ has repurposed the auto keyword for
a quite different use, so simply not using auto as a storage-class specifier is better for C/C++
compatibility.


int loop(int n)
{
    int m;             // m in scope
    scanf("%d", &m);
    {
         int i;          // both m and i in scope
         for (i = m; i < n; i++)
          puts("i is local to a sub-block\n");
     }
     return m;           // m in scope, i gone
}

A variable in an inner block that has the same name as one in the outer block will hide the outer definition.
However, when execution exits the inner block, the outer variable comes back into scope.

// hiding.c -- variables in blocks
#include <stdio.h>
int main()
{
    int x = 30;                                       // original x
    
    printf("x in outer block: %d at %p\n", x, &x);
    {
       int x = 77;                                     // new x, hides first x
       printf("x in inner block: %d at %p\n", x, &x);
     }
     printf("x in outer block: %d at %p\n", x, &x);
     while (x++ < 33)                                  // original x
     {
         int x = 100;                                  // new x, hides first x
         x++;
         printf("x in while loop: %d at %p\n", x, &x);
      }
     printf("x in outer block: %d at %p\n", x, &x);    // x =34, terminate the while loop
     
     return 0;
}

Automatic variables are not initialized unless you do so explicitly.

int main(void)
{ 
   int repid;
   int tents = 5;
   
The tents variable is initialized to 5 , but the repid variable ends up with whatever value
happened to previously occupy the space assigned to repid .

#### Register variables

Variables are normally stored in computer memory. With luck, register variables are stored
in the CPU registers or, more generally, in the fastest memory available, where they can be
accessed and manipulated more rapidly than regular variables. Because a register variable may
be in a register rather than in memory, you can’t take the address of a register variable. In most
other respects, register variables are the same as automatic variables. That is, they have block
scope, no linkage, and automatic storage duration. A variable is declared by using the storage
class specifier register :

int main(void)
{
register int quick;

We say “with luck” because declaring a variable as a register class is more a request than
a direct order. The compiler has to weigh your demands against the number of registers or
amount of fast memory available, or it can simply ignore the request, so you might not get
your wish. In that case, the variable becomes an ordinary automatic variable; however, you still
can’t use the address operator with it.

You can request that formal parameters be register variables. Just use the keyword in the function
heading:

void macho(register int n)

The types that can be declared register may be restricted. For example, the registers in a
processor might not be large enough to hold type double .



#### Static variables with block scope

The name static variable sounds like a contradiction, like a variable that can’t vary. Actually,
static means that the variable stays put in memory, not necessarily in value. Variables with
file scope automatically (and necessarily) have static storage duration. As mentioned earlier,
you also can create local variables having block scope but static duration. These variables have
the same scope as automatic variables, but they don’t vanish when the containing function
ends its job. That is, such variables have block scope, no linkage, but static storage duration.
The computer remembers their values from one function call to the next—such variables are
created by declaring them in a block (which provides the block scope and lack of linkage) with
the storage-class specifier static (which provides the static storage duration). The example in
Listing 12.3 illustrates this technique.

/* loc_stat.c -- using a local static variable */
#include <stdio.h>
void trystat(void);
int main(void)
{
   int count;
   
   for (count = 1; count <= 3; count++)
    {
      printf("Here comes iteration %d:\n", count);
      trystat();
    }
    
    return 0;
}

void trystat(void)
{
     int fade = 1;
     static int stay = 1;
     
     printf("fade = %d and stay = %d\n", fade++, stay++);
}


Here is the output:

Here comes iteration 1:
fade = 1 and stay = 1
Here comes iteration 2:
fade = 1 and stay = 2
Here comes iteration 3:
fade = 1 and stay = 3

The static variable stay remembers that its value was increased by 1, but the fade variable
starts anew each time. This points out a difference in initialization: fade is initialized each time
trystat() is called, but stay is initialized just once, when trystat() is compiled. Static variables
are initialized to zero if you don’t explicitly initialize them to some other value.
The two declarations look similar:

int fade = 1;
static int stay = 1;

However, the first statement is really part of the trystat() function and is executed each
time the function is called. It is a runtime action. The second statement isn’t actually part of
the trystat() function. If you use a debugger to execute the program step-by-step, you’ll
see that the program seems to skip that step. That’s because static variables and external variables
are already in place after a program is loaded into memory. Placing the statement in the
trystat() function tells the compiler that only the trystat() function is allowed to see the
variable; it’s not a statement that’s executed during runtime.

You can’t use static for function parameters:

int wontwork(static int flu); // not allowed

Another term for a static variable with block scope is a “local static variable.” Also, if you read
some of the older C literature, you’ll find this storage class referred to as the internal static
storage class . However, the word internal was used to indicate internal to a function, not internal
linkage.


#### Static variables with external linkage

A static variable with external linkage has file scope, external linkage, and static storage duration.
This class is sometimes termed the external storage class , and variables of this type are called external variables .
Declarations look like this:


int Errupt;            /* externally defined variable */
double Up[100];        /* externally defined array */
extern char Coal;      /* mandatory declaration if */
                       /* Coal defined in another file */
void next(void);
int main(void)
{
   extern int Errupt; /* optional declaration */
   extern double Up[]; /* optional declaration */
   ...
}

void next(void)
{
...
}


The following three examples show four possible combinations of external and automatic variables. 
Example 1 contains one external variable: Hocus . It is known to both main() and magic() .

/* Example 1 */
int Hocus;
int magic();
int main(void)
{
  extern int Hocus; // Hocus declared external
  ...
}

int magic()
{
  extern int Hocus; // same Hocus as above
  ...
}

Example 2 has one external variable, Hocus , known to both functions. This time, magic()
knows it by default.
/* Example 2 */
int Hocus;
int magic();
int main(void)
{
extern int Hocus; // Hocus declared external
...
}
int magic()
{
// Hocus not declared but is known
...
}

In Example 3, four separate variables are created. The Hocus variable in main() is automatic
by default and is local to main . The Hocus variable in magic() is automatic explicitly and is
known only to magic() . The external Hocus variable is not known to main() or magic()
but would be known to any other function in the file that did not have its own local Hocus .
Finally, Pocus is an external variable known to magic() but not to main() because Pocus
follows main() .

/* Example 3 */
int Hocus;
int magic();
int main(void)
{
   int Hocus; // Hocus declared, is auto by default
  ...
}

int Pocus;

int magic()
{
  auto int Hocus; // local Hocus declared automatic
  ...
}

These examples illustrate the scope of external variables: from the point of declaration to the
end of the file. They also illustrate the lifetimes of variables. The external Hocus and Pocus
variables persist as long as the program runs, and, because they aren’t confined to any one
function, they don’t fade away when a particular function returns.

##### Initialized external variables
   
Like automatic variables, external variables can be initialized explicitly. Unlike automatic variables,
external variables are initialized automatically to zero if you don’t initialize them. This
rule applies to elements of an externally defined array, too.

int x = 10; // ok, 10 is constant
int y = 3 + 20; // ok, a constant expression
size_t z = sizeof(int); // ok, a constant expression
int x2 = 2 * x; // not ok, x is a variable
int n;           // equivelent to int n = 0

##### Using an external variable

/* global.c -- uses an external variable */
#include <stdio.h>
int units = 0;            /* an external variable */
void critic(void);
int main(void)
{
  extern int units;     /* an optional redeclaration */
  printf("How many pounds to a firkin of butter?\n");
  scanf("%d", &units);
  while ( units != 56)
  critic();
  printf("You must have looked it up!\n");
  return 0;
}

void critic(void)
{
  /* optional redeclaration omitted */
  printf("No luck, my friend. Try again.\n");
  scanf("%d", &units);
}

So both the main() function and the critic() function use the identifier units to access the same variable. 
In C terminology, we say that units has file scope, external linkage, and static storage duration.



##### Definitions and declarations
Let’s take a longer look at the difference between defining a variable and declaring it.

int tern = 1;      /* tern defined */
main()
{
external int tern;   /* use a tern defined elsewhere */

The first declaration causes storage to be set aside for the variable.
It constitutes a definition of the variable. The second declaration merely tells the compiler
to use the tern variable that has been created previously, so it is not a definition. The first
declaration is called a defining declaration , and the second is called a referencing declaration. The
keyword extern indicates that a declaration is not a definition because it instructs the compiler to look elsewhere.

Suppose you do this:
extern int tern;
int main(void)
{

The compiler will assume that the actual definition of tern is somewhere else in your program,
perhaps in another file. This declaration does not cause space to be allocated. Therefore, don’t
use the keyword extern to create an external definition; use it only to refer to an existing external definition.

An external variable can be initialized only once, and that must occur when the variable is
defined. Suppose you have this:

// file one.c
char permis = 'N';
...
// file two.c
extern char permis = 'Y'; /* error */


#### Static variables with internal linkage

Variables of this storage class have static storage duration, file scope, and internal linkage. You
create one by defining it outside of any function (just as with an external variable) with the
storage class specifier static :

static int svil = 1; // static variable, internal linkage
int main(void)
{

The ordinary external variable can be used by functions in any file that’s part of the program, 
but the static variable with internal linkage can be used only by functions in the same file.
You can redeclare any file scope variable within a function by using the storage class specifier extern .
Such a declaration doesn’t change the linkage. Consider the following code:

int traveler = 1;          // external linkage
static int stayhome = 1;   // internal linkage
int main()
{
   extern int traveler;    // use global traveler
   extern int stayhome;    // use global stayhome
   ...
   
Both traveler and stayhome are global for this particular translation unit, but only traveler
can be used by code in other translation units. The two declarations using extern document
that main() is using the two global variables, but stayhome continues to have internal linkage.

#### Multiple files

The difference between internal linkage and external linkage is important only when you have
a program built from multiple translation units, so let’s take a quick look at that topic.

Complex C programs often use several separate files of source code. Sometimes these files
might need to share an external variable. The C way to do this is to have a defining declaration
in one file and referencing declarations in the other files. That is, all but one declaration (the
defining declaration) should use the extern keyword, and only the defining declaration should
be used to initialize the variable.

Note that an external variable defined in one file is not available to a second file unless it is
also declared (by using extern ) in the second file. An external declaration by itself only makes
a variable potentially available to other files.

Historically, however, many compilers have followed different rules in this regard. Many Unix
systems, for example, enable you to declare a variable in several files without using the extern
keyword, provided that no more than one declaration includes an initialization. If there is a
declaration with an initialization, it is taken to be the definition.


#### Storage-class specifier roundup

You may have noticed that the meaning of the keywords static and extern depends on the
context. The C language has six keywords that are grouped together as storage-class specifiers.
They are auto , register , static , extern , Thread_local , and typedef . The typedef
keyword doesn’t say anything about memory storage, but it is thrown in for syntax reasons. In
particular, in most cases you can use no more than one storage-class specifier in a declaration,
so that means you can’t use one of the other storage-class specifiers as part of a typedef . The
one exception is that Thread_local may be used together with static and extern .

The auto specifier indicates a variable with automatic storage duration. It can be used only in
declarations of variables with block scope, which already have automatic storage duration, so
its main use is documenting intent.

The register specifier also can be used only with variables of block scope. It puts a variable
into the register storage class, which amounts to a request to minimize the access time for that
variable. It also prevents you from taking the address of the variable.

The static specifier creates an object with static duration, one that’s created when the
program is loaded and ends when the program terminates. If static is used with a file scope
declaration, scope is limited to that one file. If static is used with a block scope declaration,
scope is limited to that block. Thus, the object exists and retains its value as long as the
program is running, but it can be accessed by the identifier only when code within the block
is being executed. A static variable with block scope has no linkage. A static variable with file
scope has internal linkage.

The extern specifier indicates that you are declaring a variable that has been defined elsewhere.
If the declaration containing extern has file scope, the variable referred to must have
external linkage. If the declaration containing extern has block scope, the referred-to variable
can have either external linkage or internal linkage, depending on the defining declaration for
that variable.


  Summary: Storage Classes
Automatic variables have block scope, no linking, and automatic storage duration. They are
local and private to the block (typically a function) in which they are defined. Register variables
have the same properties as automatic variables, but the compiler may use faster memory or a
register to store them. You can’t take the address of a register variable.

Variables with static storage duration can have external linkage, internal linkage, or no linkage.
When a variable is declared external to any function in a file, it’s an external variable and has
file scope, external linkage, and static storage duration. If you add the keyword static to such
a declaration, you get a variable with static storage duration, file scope, and internal linkage.
If you declare a variable inside a function and use the keyword static , the variable has static
storage duration, block scope, and no linkage.

Memory for a variable with automatic storage duration is allocated when program execution
enters the block containing the variable declaration and is freed when the block is exited. If
uninitialized, such a variable has a garbage value. Memory for a variable with static storage
duration is allocated at compile time and lasts as long as the program runs. If uninitialized,
such a variable is set to 0.

A variable with block scope is local to the block containing the declaration. A variable with file
scope is known to all functions in a file (or translation unit) following its declaration. If a file
scope variable has external linkage, it can be used by other translation units in the program.
If a file scope variable has internal linkage, it can be used just within the file in which it is
declared.


#### Storage-class and functions
Functions, too, have storage classes. A function can be either external (the default) or static.
An external function can be accessed by functions in other files, but a static function can be used
only within the defining file. Consider, for example, a file containing these function prototypes:

  double gamma(double);           /* external by default */
  static double beta(int, int);
  extern double delta(double, int);
  
The functions gamma() and delta() can be used by functions in other files that are part of the
program, but beta() cannot. Because this beta() is restricted to one file, you can use a different
function having the same name in the other files. One reason to use the static storage
class is to create functions that are private to a particular module, thereby avoiding the possibility
of name conflicts.

The usual practice is to use the extern keyword when declaring functions defined in other
files. This practice is mostly a matter of clarity because a function declaration is assumed to be
extern unless the keyword static is used.


#### Which storage class

The answer to the question “Which storage class?” is most often “automatic.”

One of the golden rules of protective programming is the “need to know” principle. Keep the
inner workings of each function as private to that function as possible, sharing only those variables
that need to be shared. The other classes are useful, and they are available. Before using
one, though, ask yourself whether it is necessary.

### A random-number function and a static variable


### Roll 'Em

### Allocated memory: malloc() and free()

The storage classes we discussed have one thing in common. After you decide which storage
class to use, the decisions about scope and storage duration follow automatically.

Some of this memory allocation is done automatically. For example, you can declare

float x;
char place[] = "Dancing Oxen Creek";
int plates[100];

Static data, recall, is allocated when the program is loaded into memory, and automatic data 
is allocated when program execution enters a block and deallocated when execution leaves the block.

C goes beyond this. You can allocate more memory as a program runs. The main tool is the
malloc() function, which takes one argument: the number of bytes of memory you want.
Then malloc() finds a suitable block of free memory. The memory is anonymous; that is,
malloc() allocates memory but it doesn’t assign a name to it. However, it does return the
address of the first byte of that block. Therefore, you can assign that address to a pointer variable
and use the pointer to access the memory.

You can use malloc() to request a block of storage as the program is running. 
You also need a pointer to keep track of where the block is in memory. For example, consider this code:

double * ptd;
ptd = (double *) malloc(30 * sizeof(double));

This code requests space for 30 type double values and sets ptd to point to the location. Note
that ptd is declared as a pointer to a single double and not to a block of 30 double values.
Remember that the name of an array is the address of its first element. Therefore, if you make
ptd point to the first element of the block, you can use it just like an array name. That is, you
can use the expression ptd[0] to access the first element of the block，ptd[1] to access the
second element, and so on.

You now have three ways to create an array:
■ Declare an array using constant expressions for the array dimensions and use the array
name to access elements. Such an array can be created using either static or automatic
memory.
■ Declare a variable-length array using variable expressions for the array dimensions and
use the array name to access elements. (Recall that this is a C99 feature.) This feature is
available only for automatic memory.
■ Declare a pointer, call malloc() , assign the return value to the pointer, and use the
pointer to access elements. The pointer can be either static or automatic.

You can use the second and third methods to do something you can’t do with an ordinary
declared array—create a dynamic array , one that’s allocated while the program runs and that
you can choose a size for while the program runs. Suppose, for example, that n is an integer
variable. Prior to C99, you couldn’t do the following:

      double item[n];        /* pre C99: not allowed if n is a variable */

However, you can do the following, even with a pre-C99 compiler:

       ptd = (double *) malloc(n * sizeof(double)); /* okay */

This works, and, as you’ll see, it’s a bit more flexible than the variable-length array.

Normally, you should balance each use of malloc() with a use of free() . The free() function
takes as its argument an address returned earlier by malloc() and frees up the memory
that had been allocated. Thus, the duration of allocated memory is from when malloc() is
called to allocate the memory until free() is called to free up the memory so that it can be
reused. Think of malloc() and free() as managing a pool of memory. Each call to malloc()
allocates memory for program use, and each call to free() restores memory to the pool so it
can be reused. The argument to free() should be a pointer to a block of memory allocated by
malloc() ; you can’t use free() to free memory allocated by other means, such as declaring an
array. Both malloc() and free() have prototypes in the stdlib.h header file.

Also, the exit() function, prototyped in stdlib.h , is called to terminate the program
if memory allocation fails. The value EXIT_FAILURE also is defined in that header file. The
standard provides for two return values that are guaranteed to work with all operating systems:
EXIT_SUCCESS (or, equivalently, the value 0 ) to indicate normal program termination, and
EXIT_FAILURE to indicate abnormal termination.

/* dyn_arr.c -- dynamically allocated array */
#include <stdio.h>
#include <stdlib.h> /* for malloc(), free() */
int main(void)
{
   double * ptd;
   int max = 0;
   int number;
   int i = 0;
   puts("What is the maximum number of type double entries?");
   if (scanf("%d", &max) != 1)                       // finds the desired array size
    {
      puts("Number not correctly entered -- bye.");
      exit(EXIT_FAILURE);
    }
    ptd = (double *) malloc(max * sizeof (double));  //allocates enough space and assigns the address to the pointer
    if (ptd == NULL)                                 // the program terminates if the malloc() fails.
    {
       puts("Memory allocation failed. Goodbye.");
       exit(EXIT_FAILURE);
     }
    /* ptd now points to an array of max elements */
    puts("Enter the values (q to quit):");
    while (i < max && scanf("%lf", &ptd[i]) == 1)
        ++i;
    printf("Here are your %d entries:\n", number = i);
    for (i = 0; i < number; i++)
       {
          printf("%7.2f ", ptd[i]);
          if (i % 7 == 6)
              putchar('\n');
        }
    if (i % 7 != 0)
        putchar('\n');
    puts("Done.");
    free(ptd);                                           //frees memory allocated by malloc()
    
   

#### The importance of free()

...
int main()
{
double glad[2000];
int i;
...for (i = 0; i < 1000; i++)
gobble(glad, 2000);
...}
void gobble(double ar[], int n)
{
double * temp = (double *) malloc( n * sizeof(double));
... /* free(temp); // forgot to use free() */
}

The first time gobble() is called, it creates the pointer temp , and it uses malloc() to allocate
16,000 bytes of memory (assuming double is 8 bytes). Suppose, as indicated, we don’t use
free() . When the function terminates, the pointer temp , being an automatic variable, disappears.
But the 16,000 bytes of memory it pointed to still exists. It can’t be accessed because we
no longer have the address. It can’t be reused because we didn’t call free() .

But the loop executes 1,000 times, so by the time the loop finishes, 16,000,000 bytes of
memory have been removed from the memory pool. This sort of problem is called a memory leak , 
and it could have been prevented by having a call to free() at the end of the function.

#### The calloc() function

Another option for memory allotment is to use calloc() . A typical use looks like this:

long * newmem;
newmem = (long *)calloc(100, sizeof (long));

This new function takes two arguments, both of which should be unsigned integers.
The calloc() function throws in one more feature: It sets all the bits in the block to zero.
The free() function can also be used to free memory allocated by calloc() .

####  Dynamic memory allocation and variable-length arrays

int vlamal()
{
int n;
int * pi;
scanf("%d", &n);
pi = (int *) malloc (n * sizeof(int));
int ar[n]; // vla
pi[2] = ar[2] = -5;
...
}


One difference is that the VLA is automatic storage.One consequence of automatic storage is
that the memory space used by the VLA is freed automatically when the execution leaves the
defining block.

VLAs are more convenient for multidimensional arrays. You can create a two-dimensional array
using malloc() , but the syntax is awkward. If a compiler doesn’t support the VLA feature, one
of the dimensions has to be fixed, just like in function calls:
int n = 5;
int m = 6;
int ar2[n][m]; // n x m VLA
int (* p2)[6]; // works pre-C99
int (* p3)[m]; // requires VLA support
p2 = (int (*)[6]) malloc(n * 6 * sizeof(int)); // n * 6 array
p3 = (int (*)[m]) malloc(n * m * sizeof(int)); // n * m array
// above expression also requires VLA support
ar2[1][2] = p2[1][2] = 12;
 

####  Storage classes and dynamic memory allocation

You might be wondering about the connection between storage classes and dynamic memory
allocation. Let’s look at an idealized model. You can think of a program as dividing its available
memory into three separate sections: one for static variables with external linkage, internal
linkage, and no linkage; one for automatic variables; and one for dynamically allocated
memory.


### ANSI C type qualitiers

You’ve seen that a variable is characterized by both its type and its storage class. C90 added
two more properties: constancy and volatility. These properties are declared with the keywords
const and volatile , which create qualified types . The C99 standard added a third qualifier,
restrict , designed to facilitate compiler optimizations. And C11 adds a fourth, Atomic . C11
provides an optional library, managed by stdatomic.h , to support concurrent programming,
and Atomic is part of that optional support.
C99 granted type qualifiers a new property—they now are idempotent! Although this sounds
like a powerful claim, all it really means is that you can use the same qualifier more than once
in a declaration, and the superfluous ones are ignored:

const const const int n = 6; // same as const int n = 6;

This makes it possible, for example, for the following sequence to be accepted:

typedef const int zip;
const zip q = 8;


#### The const type qualifier
To review, the const keyword in a declaration establishes a variable whose value cannot be modified by assignment 
or by incrementing or decrementing. On an ANSI-compliant compiler, the code 

  const int nochange;    /* qualifies m as being constant */
  nochange = 12;         /* not allowed */

should produce an error message. You can, however, initialize a const variable. Therefore, the
following code is fine:

const int nochange = 12; /* ok */

You can use the const keyword to, for example, create an array of data that the program can’t alter:

     const int days1[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
     
##### Using const with Pointers and Parameter Declarations

Using the const keyword when declaring a Pointer is complicated because you have to distinguish 
between making the pointer itself const and making the value that is pointed to const . The declaration

     const float * pf;     /* pf points to a constant float value */

establishes that pf points to a value that must remain constant. The value of pf itself can
be changed. For example, it can be set to point at another const value. In contrast, the declaration

     float * const pt;     /* pt is a const pointer */
    
says that the pointer pt itself cannot have its value changed. It must always point to the same
address, but the pointed-to value can change. Finally, the declaration
     const float * const ptr;
means both that ptr must always point to the same location and that the value stored at the location must not change.
There is a third location in which you can place const :

       float const * pfc;   // same as const float * pfc;

As the comment indicates, placing const after the type name and before the * means that the
pointer can’t be used to change the pointed-to value. In short, a const anywhere to the left
of the * makes the data constant; and a const to the right of the * makes the pointer itself constant.

If the pointer is used to alter data in the calling function, the const keyword isn’t used. For example, 
the ANSI C declaration for strcat() is this:

char *strcat(char * restrict s1, const char * restrict s2);

Recall that strcat() adds a copy of the second string to the end of the first string. This modifies
the first string, but leaves the second string unchanged. The declaration reflects this. We’ll
get back to the role of restrict in a short while.

##### Using const with Global Data
Recall that using global variables is considered a risky approach because it exposes data to being
mistakenly altered by any part of a program. That risk disappears if the data is constant, so it is
perfectly reasonable to use global variables with the const qualifier. You can have const variables,
const arrays, and const structures.

One area that requires care, however, is sharing const data across files. There are two strategies
you can use. The first is to follow the usual rules for external variables—use defining declarations
in one file and reference declarations (using the keyword extern ) in the other files:

    /* file1.c -- defines some global constants */
    const double PI = 3.14159;
    const char * MONTHS[12] =
    {"January", "February", "March", "April", "May", "June", "July",
      "August", "September", "October", "November", "December"};
      
    /* file2.c -- use global constants defined elsewhere */
    extern const double PI;
    extern const * MONTHS[];
    
The second approach is to place the constants in an include file. Here, you must take the additional
step of using the static external storage class:

    /* constant.h -- defines some global constants */
    static const double PI = 3.14159;
    static const char * MONTHS[12] =
    {"January", "February", "March", "April", "May", "June", "July",
    "August", "September", "October", "November", "December"};
    
    /* file1.c -- use global constants defined elsewhere */
    #include "constant.h" 
    
    /* file2.c -- use global constants defined elsewhere */
    #include "constant.h"

If you don’t use the keyword static , including constant.h in file1.c and in file2.c
would result in each file having a defining declaration of the same identifier, which is not
supported by the C standard. (Some compilers, however, do allow it.) By making each identifier
static external, you actually give each file a separate copy of the data. That wouldn’t work if the
files are supposed to use the data to communicate with one another because each file would see
only its own copy. Because the data is constant (by using the const keyword) and identical (by
having both files include the same header file), however, that’s not a problem.

The advantage of the header file approach is that you don’t have to remember to use defining
declarations in one file and reference declarations in the next; all files simply include the same
header file. The disadvantage is that the data is duplicated. For the preceding examples, that’s
not a real problem, but it might be one if your constant data includes enormous arrays.


#### The volatile type qualifier

The volatile qualifier tells the compiler that a variable can have its value altered by agencies
other than the program. It is typically used for hardware addresses and for data shared with
other programs or threads running simultaneously. For example, an address might hold the
current clock time. The value at that address changes as time changes, regardless of what your
program is doing. Or an address could be used to receive information transmitted from, say,
another computer.
The syntax is the same as for const :

    volatile int loc1;     /* loc1 is a volatile location */
    volatile int * ploc;   /* ploc points to a volatile location */
    
You may think that volatile is an interesting concept, but you might be wondering why the
ANSI committee felt it necessary to make volatile a keyword. The reason is that it facilitates
compiler optimization. Suppose, for example, you have code like this:

    val1 = x;
    /* some code not using x */
    val2 = x;

A smart (optimizing) compiler might notice that you use x twice without changing its value. It
would temporarily store the x value in a register. Then, when x is needed for val2 , it can save
time by reading the value from a register instead of from the original memory location. This
procedure is called caching . Ordinarily, caching is a good optimization, but not if x is changed
between the two statements by some other agency. If there were no volatile keyword, a
compiler would have no way of knowing whether this might happen. Therefore, to be safe,
the compiler couldn’t cache. That was the pre-ANSI situation. Now, however, if the volatile
keyword is not used in the declaration, the compiler can assume that a value hasn’t changed
between uses, and it can then attempt to optimize the code.
A value can be both const and volatile . For example, the hardware clock setting normally
should not be changed by the program, making it const , but it is changed by an agency other
than the program, making it volatile . Just use both qualifiers in the declaration, as shown
here; the order doesn’t matter:

     volatile const int loc;
     const volatile int * ploc;
      

#### The restrict type qualifier

The restrict keyword enhances computational support by giving the compiler permission
to optimize certain kinds of code. It can be applied only to pointers, and it indicates that a
pointer is the sole initial means of accessing a data object. To see why this is useful, we need to
look at a few examples. Consider the following:

    int ar[10];
    int * restrict restar = (int *) malloc(10 * sizeof(int));
    int * par = ar;

Here, the pointer restar is the sole initial means of access to the memory allocated by
malloc() . Therefore, it can be qualified with the keyword restrict . The pointer par ,
however, is neither the initial nor the sole means of access to the data in the ar array, so it
cannot be qualified as restrict .
Now consider the following rather artificial example, in which n is an int :

    for (n = 0; n < 10; n++)
    {
      par[n] += 5;
      restar[n] += 5;
      ar[n] *= 2;
      par[n] += 3;
      restar[n] += 3;
    }
    
Knowing that restar is the sole initial means of access to the block of data it points to, the
compiler can replace the two statements involving restar with a single statement having the
same effect:

    restar[n] += 8;   /* ok replacement */

It would be a computational error, however, to condense the two statements involving par
into one:

    par[n] += 8;    / * gives wrong answer */

The reason it gives the wrong answer is that the loop uses ar to change the value of the data
between the two times par accesses the same data. 

Without the restrict keyword, the compiler has to assume the worse case; namely, that
some other identifier might have changed the data in between two uses of a pointer. With the
restrict keyword used, the compiler is free to look for computational shortcuts.

You can use the restrict keyword as a qualifier for function parameters that are pointers.
This means that the compiler can assume that no other identifiers modify the pointed-to data
within the body of the function and that the compiler can try optimizations it might not
otherwise use. For example, the C library has two functions for copying bytes from one location
to another. Under C99, they have these prototypes:

void * memcpy(void * restrict s1, const void * restrict s2, size_t n);
void * memmove(void * s1, const void * s2, size_t n);

Each one copies n bytes from location s2 to location s1 . The memcpy() function requires that
there be no overlap between the two locations, but memmove() doesn’t have that requirement.
Declaring s1 and s2 as restrict means each pointer is a sole means of access, so they can’t
access the same block of data. This matches the requirement that there be no overlap. The
memmove() function, which does allow overlap, has to be more careful about copying data so
that it doesn’t overwrite data before it is used.

The keyword restrict has two audiences. One is the compiler, and it tells the compiler it is
free to make certain assumptions concerning optimization. The other audience is the user, and
it tells the user to use only arguments that satisfy the restrict requirements. In general, the
compiler can’t check whether you obey this restriction, but you flout it at your own risk.

#### The atomic type qualifier

Concurrent programming divides program execution into threads that may be executed in
parallel. This creates several programming challenges, including how to manage different
threads that access the same data. C11 provides, as an option and not a requirement, management
methods set up by the optional header files stdatomic.h and threads.h . One aspect is
the concept of an atomic type for which access is controlled by various macro functions. While
a thread performs an atomic operation on an object of atomic type, other threads won’t access
that object. For instance, something like

    int hogs;   // regular declaration
    hogs = 12;   // regular assignment

 could be replaced by the following:

    Atomic int hogs;   // hogs an atomic variable
    atomic_store(&hogs, 12);   // macro from stdatomic.h

Here, the storing of the value 12 in hogs is an atomic process during which other threads
won’t access hogs .
At the time of this writing, compiler support for this feature is anticipated.

#### New places for old keywords 

C99 allows you to place the type qualifiers and the storage class qualifier static inside the
initial brackets of a formal parameter in a function prototype and function header. In the case
of the type qualifiers, this provides an alternative syntax for an existing capability. For example,
here is a declaration with the older syntax:

  void ofmouth(int * const a1, int * restrict a2, int n); // older style

It says that a1 is a const pointer to int , which, as you’ll recall, means that the pointer is
constant, not the data to which it points. It also indicates that a2 is a restricted pointer, as
described in the preceding section. The new and equivalent syntax is

  void ofmouth(int a1[const], int a2[restrict], int n); // allowed by C99

Basically, the new rule allows you to use these two qualifiers with either pointer or array notation
in declaring function parameters.
The case for static is different because it introduces a new and unrelated use for this keyword.
Instead of indicating the scope or linkage of a static storage variable, the new use is to tell the
compiler how a formal parameter will be used. For example, consider this prototype:

    double stick(double ar[static 20]);

This use of static indicates that the actual argument in a function call will be a pointer to
the first element of an array having at least 20 elements. The purpose of this is to enable the
compiler to use that information to optimize its coding of the function. Why use the keyword
in such a different fashion? The C standards committee is reluctant to create a new keyword
because that would invalidate old programs that use that word as an identifier, so if they can
squeeze a new use out of an old keyword, they will.

As with restrict , the keyword static has two audiences. One is the compiler, and it tells the
compiler it is free to make certain assumptions concerning optimization. The other audience is
the user, and it tells the user to only provide arguments that satisfy the static requirements.

### Key concepts

C provides several models for managing memory. You should become familiar with the various
choices. You also need to develop a sense of when to choose the various types. Most of the
time, the automatic variable is the best choice. If you decide to use another type, you should
have a good reason. For communicating between functions, it’s usually better to use automatic
variables, function parameters, and return values rather than global variables. On the other
hand, global variables are particularly useful for constant data.

You should try to understand the properties of static memory, automatic memory, and allocated
memory. In particular, be aware that the amount of static memory used is determined
at compile time, and that static data is loaded into memory when the program is loaded into
memory. Automatic variables are allocated and freed as the program runs, so the amount of
memory used by automatic variables changes while a program executes. You can think of automatic
memory as a rewriteable workspace. Allocated memory also grows and shrinks, but, in
this case, the process is controlled by function calls rather than happening automatically.

### Summary

The memory used to store data in a program can be characterized by storage duration, scope,
and linkage. Storage duration can be static, automatic, or allocated. If static, memory is allocated
at the start of program execution and persists as long as the program is running. If automatic,
memory for a variable is allocated when program execution enters the block in which
the variable is defined and is freed when the block is exited. If allocated, memory is allocated
by calling malloc() (or a related function) and freed by calling the free() function.
Scope determines which parts of a program can access the data. A variable defined outside of
any function has file scope and is visible to any function defined after the variable’s declaration.
A variable defined inside a block or as a function parameter has block scope and is visible
just in that block and any blocks nested in it.
Linkage describes the extent to which a variable defined in one unit of a program can be linked
to elsewhere. Variables with block scope, being local, have no linkage. Variables with file scope
can have internal linkage or external linkage. Internal linkage means the variable can be used
only in the file containing the definition. External linkage means the variable also can be used
in other files.
The following are C’s five storage classes (excluding thread concepts):
  ■ Automatic— A variable declared in a block (or as a parameter in a function header)
    with no storage class modifier, or with the auto storage class modifier, belongs to the
    automatic storage class. It has automatic storage duration, block scope, and no linkage.
    Its value, if uninitialized, is not undetermined.
  ■ Register— A variable declared in a block (or as a parameter in a function header) with
    the register storage class modifier belongs to the register storage class. It has automatic
    storage duration, block scope, and no linkage, and its address cannot be taken. Declaring
    a variable as a register variable is a hint to the compiler to provide the fastest access
    possible. Its value, if uninitialized, is not undetermined.
  ■ Static, no linkage— A variable declared in a block with the static storage class modifier
    belongs to the “static, no linkage” storage class. It has static storage duration, block
    scope, and no linkage. It is initialized just once, at compile time. If not initialized
    explicitly, its bytes are set to 0.
  ■ Static, external linkage— A variable defined external to any function and without using
    the static storage class modifier belongs to the “static, external linkage” storage class.
    It has static storage duration, file scope, and external linkage. It is initialized just once, at
    compile time. If not initialized explicitly, its bytes are set to 0.
  ■ Static, internal linkage— A variable defined external to any function and using the
    static storage class modifier belongs to the “static, internal linkage” storage class. It
    has static storage duration, file scope, and internal linkage. It is initialized just once, at
    compile time. If not initialized explicitly, its bytes are set to 0.
    
Allocated memory is provided by using the malloc() (or related) function, which returns a
pointer to a block of memory having the requested number of bytes. This memory can be made
available for reuse by calling the free() function, using the address as the argument.

The type qualifiers are const , volatile , and restrict . The const specifier qualifies data as
being constant. When used with pointers, const can indicate that the pointer itself is constant
or that the data it points to is constant, depending on the placement of const in the declaration.
The volatile specifier indicates that data may be altered by processes other than the
program. Its purpose is to warn the compiler to avoid optimizations that assume otherwise.
The restrict specifier is also provided for reasons of optimization. A pointer qualified with
restrict is identified as providing the only access to a block of data.

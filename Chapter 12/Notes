
## Chapter 12 Storage classes, linkage, and memory management

One of C’s strengths is that it enables you to control a program’s fine points. C’s memory
management system exemplifies that control by letting you determine which functions know
which variables and for how long a variable persists in a program. Using memory storage is one
more element of program design.

### Storage classes
C provides several different models, or storage classes , for storing data in memory.

Every programming example in this book stores data in memory. There is a hardware aspect
to this—each stored value occupies physical memory. C literature uses the term object for such
a chunk of memory. An object can hold one or more values. An object might not yet actually
have a stored value, but it will be of the right size to hold an appropriate value. (The phrase
object-oriented programming uses the word object in a more developed sense to indicate class 
objects, whose definitions encompass both data and permissible operations on the data; C is
not an object-oriented programming language.)

There also is a software aspect—the program needs way to access the object. This can be
accomplished, for instance, by declaring a variable:

int entity = 3;

This declaration creates an identifier called entity . An identifier is a name, in this case one
that can be used to designate the contents of a particular object.In this case, the identifier
entity is how the software (the C program) designates the object that’s stored in hardware
memory. This declaration also provides a value to be stored in the object.

A variable name isn’t the only way to designate an object. For instance, consider the following
declarations:
int * pt = &entity;
int ranks[10];

In the first case, pt is an identifier. It designates an object that holds an address. 
Next, the expression *pt is not an identifier because it’s not a name. However, it does designate an object, 
in this case the same object that entity designates. In general, as you may recall from
Chapter 3 , “Data and C,” an expression that designates an object is called an lvalue.
So entity is an identifier that is an lvalue, and *pt is an expression that is an lvalue.
Along the samelines, the expression (ranks + 2 * entity) is neither an identifier (not a name) nor an lvalue
(doesn’t designate the contents of a memory location). But the expression *(ranks + 2 *entity) 
is an lvalue because it does designate the value of a particular memory location, the
seventh element of the ranks array (rank[6]). The declaration of ranks , by the way, creates an object
capable of holding ten ints , and each member of the array also is an object.

If, as with all these examples, you can use the lvalue to change the value in an object, it’s a
modifiable lvalue . Now consider this declaration:

const char * pc = "Behold a string literal!";

This causes the program to store the string literal contents in memory, and that array of character
values is an object. Each character in the array also is an object, as it can be accessed
individually. The declaration also creates an object having the identifier pc and holding the
address of that string. The identifier pc is a modifiable lvalue because it can be reset to point to
a different string. The const prevents you from altering the contents of a pointed-to string but
not from changing which string is pointed to. So *pc , which designates the data object holding
the 'B' character, is an lvalue, but not a modifiable lvalue. Similarly, the string literal itself,
because it designates the object holding the character string, is an lvalue, but not a modifiable
one.
You can describe an object in terms of its storage duration , which is how long it stays in
memory. You can describe an identifier used to access the object by its scope and its linkage ,
which together indicate which parts of a program can use it. The different storage classes offer
different combinations of scope, linkage, and storage duration. You can have identifiers that
can be shared over several files of source code, identifiers that can be used by any function in
one particular file, identifiers that can be used only within a particular function, and even identifiers
that can be used only within a subsection of a function. You can have objects that exist
for the duration of a program and objects that exist only while the function containing them is
executing. With concurrent programming, you can have objects that exist for the duration of
a particular thread. You also can store data in memory that is allocated and freed explicitly by
means of function calls.

Next, let’s investigate the meaning of the terms scope , linkage , and storage duration . After that,
we’ll return to specific storage classes.

#### Scope

Scope describes the region or regions of a program that can access an identifier. A C variable
has one of the following scopes: block scope, function scope, function prototype scope, or file
scope . The program examples to date have used block scope almost exclusively for variables. A
block , as you’ll recall, is a region of code contained within an opening brace and the matching
closing brace. For instance, the entire body of a function is a block. Any compound statement
within a function also is a block. A variable defined inside a block has block scope , and it is
visible from the point it is defined until the end of the block containing the definition. Also,
formal function parameters, even though they occur before the opening brace of a function,
have block scope and belong to the block containing the function body. So the local variables
we’ve used to date, including formal function parameters, have block scope. Therefore, the variables
cleo and patrick in the following code both have block scope extending to the closing
brace:

double blocky(double cleo)  // cleo 
{
  double patrick = 0.0;
   ...
   return patrick;
}

Variables declared in an inner block have scope restricted just to that block:

double blocky(double cleo)
{
  double patrick = 0.0;
  int i;
  for (i = 0; i < 10; i++)
   {
      double q = cleo * i; // start of scope for q
      ...
      patrick *= q;
   }                       // end of scope for q
   ...

   return patrick;
 }
 
 
 C99 allowing you to declare variables anywhere in a block, Eg:
 
 for (int i = 0; i < 10; i++)
     printf("A C99 feature: i = %d", i);
     
     
As part of this new feature, C99 expanded the concept of a block to include the code controlled
by a for loop, while loop, do while loop, or if statement, even if no brackets are used. So in
the previous for loop, the variable i is considered to be part of the for loop block. Therefore,
its scope is limited to the for loop. After execution leaves the for loop, the program will no
longer see that i .

Function scope applies just to labels used with goto statements. This means that even if a label
first appears inside an inner block in a function, its scope extends to the whole function. It
would be confusing if you could use the same label inside two separate blocks, and function
scope for labels prevents this from happening.
Function prototype scope applies to variable names used in function prototypes, as in the following:

int mighty(int mouse, double large);

Function prototype scope runs from the point the variable is defined to the end of the prototype
declaration. What this means is that all the compiler cares about when handling a function
prototype argument is the types; the names you use, if any, normally don’t matter, and
they needn’t match the names you use in the function definition. One case in which the
names matter a little is with variable-length array parameters:

void use_a_VLA(int n, int m, ar[n][m]);

If you use names in the brackets, they have to be names declared earlier in the prototype.
A variable with its definition placed outside of any function has file scope . A variable with file
scope is visible from the point it is defined to the end of the file containing the definition. Take
a look at this example:

#include <stdio.h>
int units = 0; /* a variable with file scope */
void critic(void);
int main(void)
{
...
}

void critic(void)
{
...
}

Here, the variable units has file scope, and it can be used in both main() and critic() .
(More exactly, units has file scope with external linkage, a distinction we’ll cover in the next
section.) Because they can be used in more than one function, file scope variables are also
called global variables .


#### Linkage

Next, let’s look at linkage. A C variable has one of the following linkages: external linkage,
internal linkage, or no linkage . Variables with block scope, function scope, or function prototype
scope have no linkage. That means they are private to the block, function, or prototype in
which they are defined. A variable with file scope can have either internal or external linkage.
A variable with external linkage can be used anywhere in a multifile program. A variable with
internal linkage can be used anywhere in a single translation unit.

Some common short cuts are to use “file scope” for “file scope with internal linkage” and “global scope” or “program scope”
for “file scope with external linkage.”

Eg:

int giants = 5; // file scope, external linkage
static int dodgers = 3; // file scope, internal linkage
int main()
{
...
}
...

The variable giants can be used by other files that are part of the same program. The dodgers
variable is private to this particular file, but can be used by any function in the file.


#### Storage duration

Scope and linkage describe the visibility of identifiers. Storage duration describes the persistence
of the objects accessed by these identifiers. A C object has one of the following four storage
durations: static storage duration, thread storage duration, automatic storage duration, or allocated
storage duration .

If an object has static storage duration, it exists throughout program execution. Variables with
file scope have static storage duration. Note that for file scope variables, the keyword static
indicates the linkage type, not the storage duration. A file scope variable declared using static
has internal linkage, but all file scope variables, using internal linkage or external linkage, have
static storage duration.

Thread storage duration comes into play in concurrent programming, in which program execution
can be divided into multiple threads. An object with thread storage duration exists from
when it’s declared until the thread terminates. Such an object is created when a declaration
that would otherwise create a file scope object is modified with the keyword Thread_local .
When a variable is declared with this specifier, each thread gets its own private copy of that
variable.

Variables with block scope normally have automatic storage duration. These variables have
memory allocated for them when the program enters the block in which they are defined, and
the memory is freed when the block is exited. The idea is that memory used for automatic variables
is a workspace or scratch pad that can be reused. For example, after a function call terminates,
the memory it used for its variables can be used to hold variables for the next function
that is called.

Variable-length arrays provide a slight exception in that they exist from the point of declaration
to the end of the block rather than from the beginning of the block to the end.
The local variables we’ve used so far fall into the automatic category. For example, in the
following code, the variables number and index come into being each time the bore() function
is called and pass away each time the function completes:

void bore(int number)
{
int index;
for (index = 0; index < number; index++)
puts("They don't make them the way they used to.\n");
return 0;
}

It is possible, however, for a variable to have block scope but static storage duration. To create
such a variable, declare it inside a block and add the keyword static to the declaration:
void more(int number)

{
int index;
static int ct = 0;
...
return 0;
}

Here the variable ct is stored in static memory; it exists from the time the program is loaded
until the program terminates. But its scope is confined to the more() function block. Only
while this function executes can the program use ct to access the object it designates.
(However, one can allow indirect access by enabling the function to provide the address of the
storage to other functions, for example, by a pointer parameter or return value.)
C uses scope, linkage, and storage duration to define several storage schemes for variables. This
book doesn’t cover concurrent programming, so we won’t go into that aspect. And we’ll discuss
allocated storage later in this chapter. That leaves five storage classes: automatic, register, static
with block scope, static with external linkage, and static with internal linkage. Table 12.1 lists
the combinations. Now that we’ve covered scope, linkage, and storage duration, we can discuss
these storage classes in more detail.
________________________________________________________________________________________________________________________
Storage Class           Duration       Scope          Linkage              How Declared
________________________________________________________________________________________________________________________
automatic                Automatic     Block            None               In a block

register                 Automatic     Block            None               In a block with the keyword register

static with
external linkage         static        File            External            Outside of all functions

static with
internal linkage         Static        File             Internal           Outside of all functions with the keyword static


static with no
linkage                   Static        Block            None                In a block with thekeyword static
___________________________________________________________________________________________________________________________


#### Automatic variables

A variable belonging to the automatic storage class has automatic storage duration, block scope,
and no linkage. By default, any variable declared in a block or function header belongs to the
automatic storage class. You can, however, make your intentions perfectly clear by explicitly
using the keyword auto , as shown here:

  int main(void)
   {
      auto int plox;
      ....
    }
    
You might do this, for example, to document that you are intentionally overriding an external
variable definition or that it is important not to change the variable to another storage class.
The keyword auto is termed a storage-class specifier . C++ has repurposed the auto keyword for
a quite different use, so simply not using auto as a storage-class specifier is better for C/C++
compatibility.


int loop(int n)
{
    int m;             // m in scope
    scanf("%d", &m);
    {
         int i;          // both m and i in scope
         for (i = m; i < n; i++)
          puts("i is local to a sub-block\n");
     }
     return m;           // m in scope, i gone
}

A variable in an inner block that has the same name as one in the outer block will hide the outer definition.
However, when execution exits the inner block, the outer variable comes back into scope.

// hiding.c -- variables in blocks
#include <stdio.h>
int main()
{
    int x = 30;                                       // original x
    
    printf("x in outer block: %d at %p\n", x, &x);
    {
       int x = 77;                                     // new x, hides first x
       printf("x in inner block: %d at %p\n", x, &x);
     }
     printf("x in outer block: %d at %p\n", x, &x);
     while (x++ < 33)                                  // original x
     {
         int x = 100;                                  // new x, hides first x
         x++;
         printf("x in while loop: %d at %p\n", x, &x);
      }
     printf("x in outer block: %d at %p\n", x, &x);    // x =34, terminate the while loop
     
     return 0;
}

Automatic variables are not initialized unless you do so explicitly.

int main(void)
{ 
   int repid;
   int tents = 5;
   
The tents variable is initialized to 5 , but the repid variable ends up with whatever value
happened to previously occupy the space assigned to repid .

#### Register variables

Variables are normally stored in computer memory. With luck, register variables are stored
in the CPU registers or, more generally, in the fastest memory available, where they can be
accessed and manipulated more rapidly than regular variables. Because a register variable may
be in a register rather than in memory, you can’t take the address of a register variable. In most
other respects, register variables are the same as automatic variables. That is, they have block
scope, no linkage, and automatic storage duration. A variable is declared by using the storage
class specifier register :

int main(void)
{
register int quick;

We say “with luck” because declaring a variable as a register class is more a request than
a direct order. The compiler has to weigh your demands against the number of registers or
amount of fast memory available, or it can simply ignore the request, so you might not get
your wish. In that case, the variable becomes an ordinary automatic variable; however, you still
can’t use the address operator with it.

You can request that formal parameters be register variables. Just use the keyword in the function
heading:

void macho(register int n)

The types that can be declared register may be restricted. For example, the registers in a
processor might not be large enough to hold type double .



#### Static variables with block scope

The name static variable sounds like a contradiction, like a variable that can’t vary. Actually,
static means that the variable stays put in memory, not necessarily in value. Variables with
file scope automatically (and necessarily) have static storage duration. As mentioned earlier,
you also can create local variables having block scope but static duration. These variables have
the same scope as automatic variables, but they don’t vanish when the containing function
ends its job. That is, such variables have block scope, no linkage, but static storage duration.
The computer remembers their values from one function call to the next—such variables are
created by declaring them in a block (which provides the block scope and lack of linkage) with
the storage-class specifier static (which provides the static storage duration). The example in
Listing 12.3 illustrates this technique.

/* loc_stat.c -- using a local static variable */
#include <stdio.h>
void trystat(void);
int main(void)
{
   int count;
   
   for (count = 1; count <= 3; count++)
    {
      printf("Here comes iteration %d:\n", count);
      trystat();
    }
    
    return 0;
}

void trystat(void)
{
     int fade = 1;
     static int stay = 1;
     
     printf("fade = %d and stay = %d\n", fade++, stay++);
}


Here is the output:

Here comes iteration 1:
fade = 1 and stay = 1
Here comes iteration 2:
fade = 1 and stay = 2
Here comes iteration 3:
fade = 1 and stay = 3

The static variable stay remembers that its value was increased by 1, but the fade variable
starts anew each time. This points out a difference in initialization: fade is initialized each time
trystat() is called, but stay is initialized just once, when trystat() is compiled. Static variables
are initialized to zero if you don’t explicitly initialize them to some other value.
The two declarations look similar:

int fade = 1;
static int stay = 1;

However, the first statement is really part of the trystat() function and is executed each
time the function is called. It is a runtime action. The second statement isn’t actually part of
the trystat() function. If you use a debugger to execute the program step-by-step, you’ll
see that the program seems to skip that step. That’s because static variables and external variables
are already in place after a program is loaded into memory. Placing the statement in the
trystat() function tells the compiler that only the trystat() function is allowed to see the
variable; it’s not a statement that’s executed during runtime.

You can’t use static for function parameters:

int wontwork(static int flu); // not allowed

Another term for a static variable with block scope is a “local static variable.” Also, if you read
some of the older C literature, you’ll find this storage class referred to as the internal static
storage class . However, the word internal was used to indicate internal to a function, not internal
linkage.


#### Static variables with external linkage

A static variable with external linkage has file scope, external linkage, and static storage duration.
This class is sometimes termed the external storage class , and variables of this type are called external variables .
Declarations look like this:


int Errupt;            /* externally defined variable */
double Up[100];        /* externally defined array */
extern char Coal;      /* mandatory declaration if */
                       /* Coal defined in another file */
void next(void);
int main(void)
{
   extern int Errupt; /* optional declaration */
   extern double Up[]; /* optional declaration */
   ...
}

void next(void)
{
...
}


The following three examples show four possible combinations of external and automatic variables. 
Example 1 contains one external variable: Hocus . It is known to both main() and magic() .

/* Example 1 */
int Hocus;
int magic();
int main(void)
{
  extern int Hocus; // Hocus declared external
  ...
}

int magic()
{
  extern int Hocus; // same Hocus as above
  ...
}

Example 2 has one external variable, Hocus , known to both functions. This time, magic()
knows it by default.
/* Example 2 */
int Hocus;
int magic();
int main(void)
{
extern int Hocus; // Hocus declared external
...
}
int magic()
{
// Hocus not declared but is known
...
}

In Example 3, four separate variables are created. The Hocus variable in main() is automatic
by default and is local to main . The Hocus variable in magic() is automatic explicitly and is
known only to magic() . The external Hocus variable is not known to main() or magic()
but would be known to any other function in the file that did not have its own local Hocus .
Finally, Pocus is an external variable known to magic() but not to main() because Pocus
follows main() .

/* Example 3 */
int Hocus;
int magic();
int main(void)
{
   int Hocus; // Hocus declared, is auto by default
  ...
}

int Pocus;

int magic()
{
  auto int Hocus; // local Hocus declared automatic
  ...
}

These examples illustrate the scope of external variables: from the point of declaration to the
end of the file. They also illustrate the lifetimes of variables. The external Hocus and Pocus
variables persist as long as the program runs, and, because they aren’t confined to any one
function, they don’t fade away when a particular function returns.

##### Initialized external variables
   
Like automatic variables, external variables can be initialized explicitly. Unlike automatic variables,
external variables are initialized automatically to zero if you don’t initialize them. This
rule applies to elements of an externally defined array, too.

int x = 10; // ok, 10 is constant
int y = 3 + 20; // ok, a constant expression
size_t z = sizeof(int); // ok, a constant expression
int x2 = 2 * x; // not ok, x is a variable
int n;           // equivelent to int n = 0

##### Using an external variable

/* global.c -- uses an external variable */
#include <stdio.h>
int units = 0;            /* an external variable */
void critic(void);
int main(void)
{
  extern int units;     /* an optional redeclaration */
  printf("How many pounds to a firkin of butter?\n");
  scanf("%d", &units);
  while ( units != 56)
  critic();
  printf("You must have looked it up!\n");
  return 0;
}

void critic(void)
{
  /* optional redeclaration omitted */
  printf("No luck, my friend. Try again.\n");
  scanf("%d", &units);
}

So both the main() function and the critic() function use the identifier units to access the same variable. 
In C terminology, we say that units has file scope, external linkage, and static storage duration.



##### Definitions and declarations
Let’s take a longer look at the difference between defining a variable and declaring it.

int tern = 1;      /* tern defined */
main()
{
external int tern;   /* use a tern defined elsewhere */

The first declaration causes storage to be set aside for the variable.
It constitutes a definition of the variable. The second declaration merely tells the compiler
to use the tern variable that has been created previously, so it is not a definition. The first
declaration is called a defining declaration , and the second is called a referencing declaration. The
keyword extern indicates that a declaration is not a definition because it instructs the compiler to look elsewhere.

Suppose you do this:
extern int tern;
int main(void)
{

The compiler will assume that the actual definition of tern is somewhere else in your program,
perhaps in another file. This declaration does not cause space to be allocated. Therefore, don’t
use the keyword extern to create an external definition; use it only to refer to an existing external definition.

An external variable can be initialized only once, and that must occur when the variable is
defined. Suppose you have this:

// file one.c
char permis = 'N';
...
// file two.c
extern char permis = 'Y'; /* error */


#### Static variables with internal linkage

Variables of this storage class have static storage duration, file scope, and internal linkage. You
create one by defining it outside of any function (just as with an external variable) with the
storage class specifier static :

static int svil = 1; // static variable, internal linkage
int main(void)
{

The ordinary external variable can be used by functions in any file that’s part of the program, 
but the static variable with internal linkage can be used only by functions in the same file.
You can redeclare any file scope variable within a function by using the storage class specifier extern .
Such a declaration doesn’t change the linkage. Consider the following code:

int traveler = 1;          // external linkage
static int stayhome = 1;   // internal linkage
int main()
{
   extern int traveler;    // use global traveler
   extern int stayhome;    // use global stayhome
   ...
   
Both traveler and stayhome are global for this particular translation unit, but only traveler
can be used by code in other translation units. The two declarations using extern document
that main() is using the two global variables, but stayhome continues to have internal linkage.

#### Multiple files

The difference between internal linkage and external linkage is important only when you have
a program built from multiple translation units, so let’s take a quick look at that topic.

Complex C programs often use several separate files of source code. Sometimes these files
might need to share an external variable. The C way to do this is to have a defining declaration
in one file and referencing declarations in the other files. That is, all but one declaration (the
defining declaration) should use the extern keyword, and only the defining declaration should
be used to initialize the variable.

Note that an external variable defined in one file is not available to a second file unless it is
also declared (by using extern ) in the second file. An external declaration by itself only makes
a variable potentially available to other files.

Historically, however, many compilers have followed different rules in this regard. Many Unix
systems, for example, enable you to declare a variable in several files without using the extern
keyword, provided that no more than one declaration includes an initialization. If there is a
declaration with an initialization, it is taken to be the definition.


#### Storage-class specifier roundup

You may have noticed that the meaning of the keywords static and extern depends on the
context. The C language has six keywords that are grouped together as storage-class specifiers.
They are auto , register , static , extern , Thread_local , and typedef . The typedef
keyword doesn’t say anything about memory storage, but it is thrown in for syntax reasons. In
particular, in most cases you can use no more than one storage-class specifier in a declaration,
so that means you can’t use one of the other storage-class specifiers as part of a typedef . The
one exception is that Thread_local may be used together with static and extern .

The auto specifier indicates a variable with automatic storage duration. It can be used only in
declarations of variables with block scope, which already have automatic storage duration, so
its main use is documenting intent.

The register specifier also can be used only with variables of block scope. It puts a variable
into the register storage class, which amounts to a request to minimize the access time for that
variable. It also prevents you from taking the address of the variable.

The static specifier creates an object with static duration, one that’s created when the
program is loaded and ends when the program terminates. If static is used with a file scope
declaration, scope is limited to that one file. If static is used with a block scope declaration,
scope is limited to that block. Thus, the object exists and retains its value as long as the
program is running, but it can be accessed by the identifier only when code within the block
is being executed. A static variable with block scope has no linkage. A static variable with file
scope has internal linkage.

The extern specifier indicates that you are declaring a variable that has been defined elsewhere.
If the declaration containing extern has file scope, the variable referred to must have
external linkage. If the declaration containing extern has block scope, the referred-to variable
can have either external linkage or internal linkage, depending on the defining declaration for
that variable.


  Summary: Storage Classes
Automatic variables have block scope, no linking, and automatic storage duration. They are
local and private to the block (typically a function) in which they are defined. Register variables
have the same properties as automatic variables, but the compiler may use faster memory or a
register to store them. You can’t take the address of a register variable.

Variables with static storage duration can have external linkage, internal linkage, or no linkage.
When a variable is declared external to any function in a file, it’s an external variable and has
file scope, external linkage, and static storage duration. If you add the keyword static to such
a declaration, you get a variable with static storage duration, file scope, and internal linkage.
If you declare a variable inside a function and use the keyword static , the variable has static
storage duration, block scope, and no linkage.

Memory for a variable with automatic storage duration is allocated when program execution
enters the block containing the variable declaration and is freed when the block is exited. If
uninitialized, such a variable has a garbage value. Memory for a variable with static storage
duration is allocated at compile time and lasts as long as the program runs. If uninitialized,
such a variable is set to 0.

A variable with block scope is local to the block containing the declaration. A variable with file
scope is known to all functions in a file (or translation unit) following its declaration. If a file
scope variable has external linkage, it can be used by other translation units in the program.
If a file scope variable has internal linkage, it can be used just within the file in which it is
declared.


#### Storage-class and functions

#### Which storage class

### A random-number function and a static variable

### Roll 'Em

### Allocated memory: malloc() and free()

#### The importance of free()
#### The calloc() function
####  Dynamic memory allocation and variable-length arrays
####  Storage classes and dynamic memory allocation

### ANSI C type qualitiers

#### The const type qualifier

#### The volatile type qualifier

#### The restrict type qualifier

#### The atomic type qualifier

#### New places for old keywords 

### Key concepts

### Summary
